DROP TABLE IF EXISTS ad CASCADE;
DROP TABLE IF EXISTS ad_text CASCADE;
DROP TABLE IF EXISTS image CASCADE;
DROP TABLE IF EXISTS video CASCADE;
DROP TABLE IF EXISTS media_asset CASCADE;
DROP TABLE IF EXISTS ad_set CASCADE;
DROP TABLE IF EXISTS campaign_platform CASCADE;
DROP TABLE IF EXISTS ad_platform CASCADE;
DROP TABLE IF EXISTS campaign CASCADE;
DROP TABLE IF EXISTS employee CASCADE;
DROP TABLE IF EXISTS client CASCADE;

CREATE TABLE client (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    email TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE employee (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    position TEXT NOT NULL,
    manager_id INTEGER REFERENCES employee(id) ON DELETE SET NULL,
    mentor_id INTEGER REFERENCES employee(id) ON DELETE SET NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE campaign (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    start_date DATE NOT NULL,
    finish_date DATE NOT NULL,
    client_id INTEGER NOT NULL REFERENCES client(id) ON DELETE CASCADE,
    manager_id INTEGER NOT NULL REFERENCES employee(id) ON DELETE RESTRICT UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_dates CHECK (finish_date >= start_date)
);

CREATE TABLE ad_platform (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE campaign_platform (
    campaign_id INTEGER NOT NULL REFERENCES campaign(id) ON DELETE CASCADE,
    platform_id INTEGER NOT NULL REFERENCES ad_platform(id) ON DELETE CASCADE,
    budget DECIMAL(12, 2) NOT NULL CHECK (budget >= 0),
    PRIMARY KEY (campaign_id, platform_id)
);

CREATE TABLE ad_set (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    target_age TEXT,
    target_gender TEXT,
    target_country TEXT,
    campaign_id INTEGER NOT NULL REFERENCES campaign(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (campaign_id, name)
);

CREATE TABLE media_asset (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    file_path TEXT NOT NULL UNIQUE,
    creation_date DATE NOT NULL DEFAULT CURRENT_DATE
);

CREATE TABLE video (
    media_asset_id INTEGER PRIMARY KEY REFERENCES media_asset(id) ON DELETE CASCADE,
    duration INTEGER NOT NULL CHECK (duration > 0 AND duration <= 600) -- 10 minutes max
);

CREATE TABLE image (
    media_asset_id INTEGER PRIMARY KEY REFERENCES media_asset(id) ON DELETE CASCADE,
    resolution TEXT NOT NULL
);

CREATE TABLE ad_text (
    id SERIAL PRIMARY KEY,
    text TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ad (
    id SERIAL PRIMARY KEY,
    ad_set_id INTEGER NOT NULL REFERENCES ad_set(id) ON DELETE CASCADE,
    media_asset_id INTEGER NOT NULL REFERENCES media_asset(id) ON DELETE CASCADE,
    ad_text_id INTEGER NOT NULL REFERENCES ad_text(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (ad_set_id, media_asset_id, ad_text_id)
);

-- ============================================================================
-- 1. Prevent duplicate subtypes (mutual exclusion at insert time)
-- ============================================================================

CREATE OR REPLACE FUNCTION prevent_duplicate_subtype()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_TABLE_NAME = 'video' THEN
        IF EXISTS(SELECT 1 FROM image WHERE media_asset_id = NEW.media_asset_id) THEN
            RAISE EXCEPTION 'Media asset % already exists as image, cannot create video', 
                NEW.media_asset_id;
        END IF;
    ELSIF TG_TABLE_NAME = 'image' THEN
        IF EXISTS(SELECT 1 FROM video WHERE media_asset_id = NEW.media_asset_id) THEN
            RAISE EXCEPTION 'Media asset % already exists as video, cannot create image', 
                NEW.media_asset_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_video_image_duplicate
    BEFORE INSERT ON video
    FOR EACH ROW
    EXECUTE FUNCTION prevent_duplicate_subtype();

CREATE TRIGGER prevent_image_video_duplicate
    BEFORE INSERT ON image
    FOR EACH ROW
    EXECUTE FUNCTION prevent_duplicate_subtype();

-- ============================================================================
-- 2. Campaign must have at least ONE platform
-- ============================================================================

CREATE OR REPLACE FUNCTION check_campaign_has_platform()
RETURNS TRIGGER AS $$
DECLARE
    platform_count INTEGER;
BEGIN
    -- Count remaining platforms for this campaign after the delete
    SELECT COUNT(*) INTO platform_count
    FROM campaign_platform
    WHERE campaign_id = OLD.campaign_id
      AND (campaign_id != OLD.campaign_id OR platform_id != OLD.platform_id);
    
    IF platform_count = 0 THEN
        RAISE EXCEPTION 'Cannot delete last platform for campaign %. Campaign must have at least one platform.', 
            OLD.campaign_id;
    END IF;
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_campaign_min_platforms
    BEFORE DELETE ON campaign_platform
    FOR EACH ROW
    EXECUTE FUNCTION check_campaign_has_platform();

CREATE OR REPLACE FUNCTION check_campaign_platform_exists()
RETURNS TRIGGER AS $$
DECLARE
    platform_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO platform_count
    FROM campaign_platform
    WHERE campaign_id = NEW.id;
    
    IF platform_count = 0 THEN
        RAISE EXCEPTION 'Campaign % must have at least one platform', NEW.id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE CONSTRAINT TRIGGER enforce_campaign_has_platforms
    AFTER INSERT OR UPDATE ON campaign
    DEFERRABLE INITIALLY DEFERRED
    FOR EACH ROW
    EXECUTE FUNCTION check_campaign_platform_exists();

-- ============================================================================
-- 3. Employee cannot be their own manager or mentor
-- ============================================================================

CREATE OR REPLACE FUNCTION check_employee_self_reference()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.manager_id IS NOT NULL AND NEW.manager_id = NEW.id THEN
        RAISE EXCEPTION 'Employee % cannot be their own manager', NEW.id;
    END IF;

    IF NEW.mentor_id IS NOT NULL AND NEW.mentor_id = NEW.id THEN
        RAISE EXCEPTION 'Employee % cannot be their own mentor', NEW.id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER prevent_employee_self_reference
    BEFORE INSERT OR UPDATE ON employee
    FOR EACH ROW
    EXECUTE FUNCTION check_employee_self_reference();